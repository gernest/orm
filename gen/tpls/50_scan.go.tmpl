// scan an SQL row to a {{$.Graph.Type.Name}} struct
// It returns the scanned {{$.Graph.Type.Ext $.Graph.Type.Package}} and the number of scanned fields,
// and an error in case of failure.
func (s *{{$.Public}}SelectBuilder) scan(dialect string, vals []driver.Value{{if $.Graph.Type.HasOneToManyRelation}}, exists map[string]*{{$.Graph.Type.Ext $.Graph.Type.Package}}{{end}}) (*{{$.Graph.Type.Ext $.Graph.Type.Package}}, int, error) {
    item, n, err := s.scanCount(dialect, vals{{if $.Graph.Type.HasOneToManyRelation}}, exists{{end}})
    if err != nil {
        return nil, n, err
    }
    return &item.{{$.Graph.Type.Name}}, n, nil
}

// ScanCount scans an SQL row to a {{$.Graph.Type.Name}}Count struct
func (s *{{$.Public}}SelectBuilder) scanCount(dialect string, vals []driver.Value{{if $.Graph.Type.HasOneToManyRelation}}, exists map[string]*{{$.Graph.Type.Ext $.Graph.Type.Package}}{{end}}) (*{{$.Graph.Type.Name}}Count, int, error) {
    switch dialect {
    {{ range $_, $dialect := $.Dialects -}}
    case "{{$dialect.Name}}":
        return s.scan{{$dialect.Name}}(vals{{if $.Graph.Type.HasOneToManyRelation}}, exists{{end}})
    {{ end -}}
    default:
        return nil, 0, fmt.Errorf("unsupported dialect %s", dialect)
    }
}

{{ range $_, $dialect := $.Dialects }}
// scan{{$dialect.Name}} scans {{$dialect.Name}} row to a {{$.Graph.Type.Name}} struct
func (s *{{$.Public}}SelectBuilder) scan{{$dialect.Name}} (vals []driver.Value{{if $.Graph.Type.HasOneToManyRelation}}, exists map[string]*{{$.Graph.Type.Ext $.Graph.Type.Package}}{{end}}) (*{{$.Graph.Type.Name}}Count, int, error) {
    var (
        row {{$.Graph.Type.Name}}Count
        i int
        rowExists bool
        all = s.params.SelectAll()
    )
    {{ range $_, $f := $.Graph.Type.Fields -}}
    {{ if not $f.IsReference -}}
    if all || s.params.Columns["{{$f.Column.Name}}"] {
        if i >= len(vals) {
            return nil, 0, fmt.Errorf("not enough columns returned: %d", len(vals))
        }
        if vals[i] != nil && !rowExists {
{{ $dialect.ConvertValueCode $f -}}
        }
        {{ if and $.Graph.Type.HasOneToManyRelation -}}
        {{ if or $f.Unique $f.PrimaryKey -}}
        // check if we scanned this item in previous rows. If we did, set `rowExists`,
        // so other columns in this table won't be evaluated. We only need values
        // from other tables.
        if exists[{{$.Private}}HashItem(&row.{{$.Graph.Type.Name}})] != nil {
            rowExists = true
        }
        {{ end -}}
        {{ end -}}
        i++
    }
    {{ end -}}
    {{ end -}}

    if s.params.Count {
        switch val := vals[i].(type) {
        case int64:
            row.Count = val
        case []byte:
            row.Count = runtime.ParseInt(val)
        default:
            return nil, 0, runtime.ErrConvert("COUNT(*)", i, vals[i], "int64, []byte")
        }
        i++
    }

    {{ range $_, $f := $.Graph.Type.References }}
    if s := s.scan{{$f.Name}}; s != nil {
        tmp, n, err := s.Scan("{{$dialect.Name}}", vals[i:]{{if $f.Type.HasOneToManyRelation}}, nil{{end}})
        if err != nil {
            return nil, 0, fmt.Errorf("sub scanning {{$f.AccessName}}, cols [%d:%d]: %s", i, len(vals), err)
        }
        {{ if $f.Type.Slice -}}
        row.{{$f.AccessName}} = append(row.{{$f.AccessName}}, {{if not $f.Type.Pointer}}*{{end}}tmp)
        {{ else -}}
        row.{{$f.AccessName}} = {{ if not $f.Type.Pointer}}*{{end}}tmp
        {{ end -}}
        i += n
    }
    {{ end }}

    return &row, i, nil
}
{{ end }}

