package gen

import (
	"fmt"
	"go/types"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

const suffix = "orm"

const header = `// Autogenerated by github.com/posener/orm
`

const tagSQLType = "sql"

var defaultSQLTypes = map[string]string{
	"string": "VARCHAR(255)",
	"int":    "INT",
	"bool":   "BOOLEAN",
	"float":  "REAL",
}

type TplProps struct {
	// Table is the table name of the given struct
	Table string
	// The name	of the new created package
	PackageName string
	// Type describes the type of the given struct to generate code for
	Type Type
}

// Type describes the type of the given struct to generate code for
type Type struct {
	// ImportPath is the import path of the package of the given struct.
	// for example: "github.com/posener/orm/example"
	ImportPath string
	// Name is the full type of the imported type, as used in a go code
	// outside the defining package. For example: "example.Person"
	Name string
	// Fields is the list of exported fields
	Fields []Field
}

type Field struct {
	Name       string
	ColumnName string
	Type       string
	// ColumnSQLType is the SQL type of the field
	ColumnSQLType string
}

var templates = template.Must(
	template.New("").
		Funcs(template.FuncMap{
			"plus1": func(x int) int { return x + 1 },
		}).
		ParseGlob("gen/*.go.tpl"))

// Gen generates all the ORM files for a given struct in a given package.
// pkg is the package of the struct
// st is the type descriptor of the struct
// name is the name of the type of the struct
func Gen(pkg *types.Package, st *types.Struct, name string) error {
	// get the package dir on disk
	dir, err := packagePath(pkg.Path())
	if err != nil {
		return err
	}

	// the new created package name is the name of the struct with "orm" suffix
	packageName := strings.ToLower(name + suffix)

	// the files will be generated in a sub package
	dir = filepath.Join(dir, packageName)
	log.Printf("Generating code to directory: %s", dir)
	err = os.MkdirAll(dir, 0775)
	if err != nil {
		return fmt.Errorf("creating directory %s: %s", dir, err)
	}

	props := TplProps{
		Table: strings.ToLower(name),
		Type: Type{
			ImportPath: pkg.Path(),
			Name:       fmt.Sprintf("%s.%s", pkg.Name(), name),
			Fields:     collectFields(st),
		},
		PackageName: packageName,
	}
	log.Printf("Template configuration: %+v", props)

	for _, tpl := range templates.Templates() {
		err := writeTemplate(tpl, props, dir)
		if err != nil {
			return err
		}
	}
	fmtOut, err := exec.Command("gofmt", "-s", "-w", dir).CombinedOutput()
	if err != nil {
		log.Printf("Failed formatting package: %s", err)
	}
	log.Printf("Format package output: %s", string(fmtOut))
	return nil
}

func packagePath(pkg string) (string, error) {
	for _, gopath := range filepath.SplitList(os.Getenv("GOPATH")) {
		pkgPath := filepath.Join(gopath, "src", pkg)
		f, err := os.Stat(pkgPath)
		if err == nil && f.IsDir() {
			return pkgPath, nil
		}
	}
	return "", fmt.Errorf("package path was not found")
}

func writeTemplate(tpl *template.Template, props TplProps, dir string) error {
	// remove the ".tpl" suffix
	fileName := tpl.Name()[:len(tpl.Name())-4]
	filePath := filepath.Join(dir, fileName)
	log.Printf("Writing file: %s", filePath)
	f, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("creating file %s: %s", filePath, err)
	}
	defer f.Close()
	f.Write([]byte(header))
	return tpl.Execute(f, props)
}

func collectFields(s *types.Struct) []Field {
	var f []Field
	for i := 0; i < s.NumFields(); i++ {
		v := s.Field(i)
		if !v.Exported() {
			continue
		}
		varType := v.Type().String()
		sqlType := customSQLTypeFromTag(varType)
		if sqlType == "" {
			sqlType = defaultSQLTypes[varType]
		}
		if sqlType == "" {
			log.Fatalf("Unsupported field type: %s", varType)
		}
		s.Tag(i)
		f = append(f, Field{
			Name:          v.Name(),
			ColumnName:    strings.ToLower(v.Name()),
			Type:          varType,
			ColumnSQLType: sqlType,
		})
	}
	return f
}

func customSQLTypeFromTag(tag string) string {
	parts := strings.Fields(tag)
	for _, part := range parts {
		keyVal := strings.Split(part, ":")
		if len(keyVal) != 2 {
			continue
		}
		key := keyVal[0]
		val := keyVal[1]
		if key != tagSQLType {
			continue
		}
		return strings.Trim(val, `"`)
	}
	return ""
}
