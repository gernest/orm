// Package allorm was auto-generated by github.com/posener/orm; DO NOT EDIT
package allorm

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"reflect"
	"time"
	"unsafe"
)

const errMsg = "converting %s: column %d with value %v (type %T) to %s"

// scanArgs are list of fields to be given to the sql Scan command
func scan(dialect string, cols columns, rows *sql.Rows) (*AllCount, error) {
	switch dialect {
	case "mysql":
		return scanmysql(cols, rows)

	case "sqlite3":
		return scansqlite3(cols, rows)
	default:
		return nil, fmt.Errorf("unsupported dialect %s", dialect)
	}
}

func scanmysql(cols columns, rows *sql.Rows) (*AllCount, error) {
	var (
		vals = values(*rows)
		row  AllCount
		all  = cols.selectAll()
		i    = 0
	)

	if all || cols.SelectAuto {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int(parseInt(val))
				row.Auto = tmp
			case int64:
				tmp := int(val)
				row.Auto = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Auto", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectNotNil {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := string(val)
				row.NotNil = tmp
			default:
				return nil, fmt.Errorf(errMsg, "NotNil", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectInt {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int(parseInt(val))
				row.Int = tmp
			case int64:
				tmp := int(val)
				row.Int = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Int", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectInt8 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int8(parseInt(val))
				row.Int8 = tmp
			case int64:
				tmp := int8(val)
				row.Int8 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Int8", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectInt16 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int16(parseInt(val))
				row.Int16 = tmp
			case int64:
				tmp := int16(val)
				row.Int16 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Int16", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectInt32 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int32(parseInt(val))
				row.Int32 = tmp
			case int64:
				tmp := int32(val)
				row.Int32 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Int32", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectInt64 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int64(parseInt(val))
				row.Int64 = tmp
			case int64:
				tmp := int64(val)
				row.Int64 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Int64", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectUInt {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint(parseFloat(val))
				row.UInt = tmp
			case int64:
				tmp := uint(val)
				row.UInt = tmp
			default:
				return nil, fmt.Errorf(errMsg, "UInt", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectUInt8 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint8(parseFloat(val))
				row.UInt8 = tmp
			case int64:
				tmp := uint8(val)
				row.UInt8 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "UInt8", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectUInt16 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint16(parseFloat(val))
				row.UInt16 = tmp
			case int64:
				tmp := uint16(val)
				row.UInt16 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "UInt16", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectUInt32 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint32(parseFloat(val))
				row.UInt32 = tmp
			case int64:
				tmp := uint32(val)
				row.UInt32 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "UInt32", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectUInt64 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint64(parseFloat(val))
				row.UInt64 = tmp
			case int64:
				tmp := uint64(val)
				row.UInt64 = tmp
			default:
				return nil, fmt.Errorf(errMsg, "UInt64", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectTime {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := parseTime(val, 3)
				row.Time = tmp
			case time.Time:
				tmp := time.Time(val)
				row.Time = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Time", i, vals[i], vals[i], "[]byte, time.Time")
			}
		}
		i++
	}

	if all || cols.SelectVarCharString {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := string(val)
				row.VarCharString = tmp
			default:
				return nil, fmt.Errorf(errMsg, "VarCharString", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectVarCharByte {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := []byte(val)
				row.VarCharByte = tmp
			default:
				return nil, fmt.Errorf(errMsg, "VarCharByte", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectString {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := string(val)
				row.String = tmp
			default:
				return nil, fmt.Errorf(errMsg, "String", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectBytes {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := []byte(val)
				row.Bytes = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Bytes", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectBool {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := parseBool(val)
				row.Bool = tmp
			case bool:
				tmp := bool(val)
				row.Bool = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Bool", i, vals[i], vals[i], "[]byte, bool")
			}
		}
		i++
	}

	if all || cols.SelectPInt {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int(parseInt(val))
				row.PInt = &tmp
			case int64:
				tmp := int(val)
				row.PInt = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PInt", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPInt8 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int8(parseInt(val))
				row.PInt8 = &tmp
			case int64:
				tmp := int8(val)
				row.PInt8 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PInt8", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPInt16 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int16(parseInt(val))
				row.PInt16 = &tmp
			case int64:
				tmp := int16(val)
				row.PInt16 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PInt16", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPInt32 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int32(parseInt(val))
				row.PInt32 = &tmp
			case int64:
				tmp := int32(val)
				row.PInt32 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PInt32", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPInt64 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int64(parseInt(val))
				row.PInt64 = &tmp
			case int64:
				tmp := int64(val)
				row.PInt64 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PInt64", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPUInt {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint(parseFloat(val))
				row.PUInt = &tmp
			case int64:
				tmp := uint(val)
				row.PUInt = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PUInt", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPUInt8 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint8(parseFloat(val))
				row.PUInt8 = &tmp
			case int64:
				tmp := uint8(val)
				row.PUInt8 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PUInt8", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPUInt16 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint16(parseFloat(val))
				row.PUInt16 = &tmp
			case int64:
				tmp := uint16(val)
				row.PUInt16 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PUInt16", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPUInt32 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint32(parseFloat(val))
				row.PUInt32 = &tmp
			case int64:
				tmp := uint32(val)
				row.PUInt32 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PUInt32", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPUInt64 {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := uint64(parseFloat(val))
				row.PUInt64 = &tmp
			case int64:
				tmp := uint64(val)
				row.PUInt64 = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PUInt64", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if all || cols.SelectPTime {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := parseTime(val, 3)
				row.PTime = &tmp
			case time.Time:
				tmp := time.Time(val)
				row.PTime = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PTime", i, vals[i], vals[i], "[]byte, time.Time")
			}
		}
		i++
	}

	if all || cols.SelectPVarCharString {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := string(val)
				row.PVarCharString = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PVarCharString", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectPVarCharByte {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := []byte(val)
				row.PVarCharByte = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PVarCharByte", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectPString {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := string(val)
				row.PString = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PString", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectPBytes {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := []byte(val)
				row.PBytes = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PBytes", i, vals[i], vals[i], "[]byte, []byte")
			}
		}
		i++
	}

	if all || cols.SelectPBool {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := parseBool(val)
				row.PBool = &tmp
			case bool:
				tmp := bool(val)
				row.PBool = &tmp
			default:
				return nil, fmt.Errorf(errMsg, "PBool", i, vals[i], vals[i], "[]byte, bool")
			}
		}
		i++
	}

	if all || cols.SelectSelect {
		if vals[i] != nil {
			switch val := vals[i].(type) {
			case []byte:
				tmp := int(parseInt(val))
				row.Select = tmp
			case int64:
				tmp := int(val)
				row.Select = tmp
			default:
				return nil, fmt.Errorf(errMsg, "Select", i, vals[i], vals[i], "[]byte, int64")
			}
		}
		i++
	}

	if cols.count {
		switch val := vals[i].(type) {
		case int64:
			row.Count = val
		case []byte:
			row.Count = parseInt(val)
		default:
			return nil, fmt.Errorf(errMsg, "COUNT(*)", i, vals[i], vals[i], "int64, []byte")
		}
	}

	return &row, nil
}

func scansqlite3(cols columns, rows *sql.Rows) (*AllCount, error) {
	var (
		vals = values(*rows)
		row  AllCount
		all  = cols.selectAll()
		i    = 0
	)

	if all || cols.SelectAuto {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Auto", i, vals[i], vals[i], "int")
			}
			tmp := int(val)
			row.Auto = tmp
		}
		i++
	}

	if all || cols.SelectNotNil {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "NotNil", i, vals[i], vals[i], "string")
			}
			tmp := string(val)
			row.NotNil = tmp
		}
		i++
	}

	if all || cols.SelectInt {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Int", i, vals[i], vals[i], "int")
			}
			tmp := int(val)
			row.Int = tmp
		}
		i++
	}

	if all || cols.SelectInt8 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Int8", i, vals[i], vals[i], "int8")
			}
			tmp := int8(val)
			row.Int8 = tmp
		}
		i++
	}

	if all || cols.SelectInt16 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Int16", i, vals[i], vals[i], "int16")
			}
			tmp := int16(val)
			row.Int16 = tmp
		}
		i++
	}

	if all || cols.SelectInt32 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Int32", i, vals[i], vals[i], "int32")
			}
			tmp := int32(val)
			row.Int32 = tmp
		}
		i++
	}

	if all || cols.SelectInt64 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Int64", i, vals[i], vals[i], "int64")
			}
			tmp := int64(val)
			row.Int64 = tmp
		}
		i++
	}

	if all || cols.SelectUInt {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "UInt", i, vals[i], vals[i], "uint")
			}
			tmp := uint(val)
			row.UInt = tmp
		}
		i++
	}

	if all || cols.SelectUInt8 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "UInt8", i, vals[i], vals[i], "uint8")
			}
			tmp := uint8(val)
			row.UInt8 = tmp
		}
		i++
	}

	if all || cols.SelectUInt16 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "UInt16", i, vals[i], vals[i], "uint16")
			}
			tmp := uint16(val)
			row.UInt16 = tmp
		}
		i++
	}

	if all || cols.SelectUInt32 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "UInt32", i, vals[i], vals[i], "uint32")
			}
			tmp := uint32(val)
			row.UInt32 = tmp
		}
		i++
	}

	if all || cols.SelectUInt64 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "UInt64", i, vals[i], vals[i], "uint64")
			}
			tmp := uint64(val)
			row.UInt64 = tmp
		}
		i++
	}

	if all || cols.SelectTime {
		if vals[i] != nil {
			val, ok := vals[i].(time.Time)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Time", i, vals[i], vals[i], "time.Time")
			}
			tmp := time.Time(val)
			row.Time = tmp
		}
		i++
	}

	if all || cols.SelectVarCharString {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "VarCharString", i, vals[i], vals[i], "string")
			}
			tmp := string(val)
			row.VarCharString = tmp
		}
		i++
	}

	if all || cols.SelectVarCharByte {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "VarCharByte", i, vals[i], vals[i], "[]byte")
			}
			tmp := []byte(val)
			row.VarCharByte = tmp
		}
		i++
	}

	if all || cols.SelectString {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "String", i, vals[i], vals[i], "string")
			}
			tmp := string(val)
			row.String = tmp
		}
		i++
	}

	if all || cols.SelectBytes {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Bytes", i, vals[i], vals[i], "[]byte")
			}
			tmp := []byte(val)
			row.Bytes = tmp
		}
		i++
	}

	if all || cols.SelectBool {
		if vals[i] != nil {
			val, ok := vals[i].(bool)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Bool", i, vals[i], vals[i], "bool")
			}
			tmp := bool(val)
			row.Bool = tmp
		}
		i++
	}

	if all || cols.SelectPInt {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PInt", i, vals[i], vals[i], "*int")
			}
			tmp := int(val)
			row.PInt = &tmp
		}
		i++
	}

	if all || cols.SelectPInt8 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PInt8", i, vals[i], vals[i], "*int8")
			}
			tmp := int8(val)
			row.PInt8 = &tmp
		}
		i++
	}

	if all || cols.SelectPInt16 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PInt16", i, vals[i], vals[i], "*int16")
			}
			tmp := int16(val)
			row.PInt16 = &tmp
		}
		i++
	}

	if all || cols.SelectPInt32 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PInt32", i, vals[i], vals[i], "*int32")
			}
			tmp := int32(val)
			row.PInt32 = &tmp
		}
		i++
	}

	if all || cols.SelectPInt64 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PInt64", i, vals[i], vals[i], "*int64")
			}
			tmp := int64(val)
			row.PInt64 = &tmp
		}
		i++
	}

	if all || cols.SelectPUInt {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PUInt", i, vals[i], vals[i], "*uint")
			}
			tmp := uint(val)
			row.PUInt = &tmp
		}
		i++
	}

	if all || cols.SelectPUInt8 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PUInt8", i, vals[i], vals[i], "*uint8")
			}
			tmp := uint8(val)
			row.PUInt8 = &tmp
		}
		i++
	}

	if all || cols.SelectPUInt16 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PUInt16", i, vals[i], vals[i], "*uint16")
			}
			tmp := uint16(val)
			row.PUInt16 = &tmp
		}
		i++
	}

	if all || cols.SelectPUInt32 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PUInt32", i, vals[i], vals[i], "*uint32")
			}
			tmp := uint32(val)
			row.PUInt32 = &tmp
		}
		i++
	}

	if all || cols.SelectPUInt64 {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PUInt64", i, vals[i], vals[i], "*uint64")
			}
			tmp := uint64(val)
			row.PUInt64 = &tmp
		}
		i++
	}

	if all || cols.SelectPTime {
		if vals[i] != nil {
			val, ok := vals[i].(time.Time)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PTime", i, vals[i], vals[i], "*time.Time")
			}
			tmp := time.Time(val)
			row.PTime = &tmp
		}
		i++
	}

	if all || cols.SelectPVarCharString {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PVarCharString", i, vals[i], vals[i], "*string")
			}
			tmp := string(val)
			row.PVarCharString = &tmp
		}
		i++
	}

	if all || cols.SelectPVarCharByte {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PVarCharByte", i, vals[i], vals[i], "*[]byte")
			}
			tmp := []byte(val)
			row.PVarCharByte = &tmp
		}
		i++
	}

	if all || cols.SelectPString {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PString", i, vals[i], vals[i], "*string")
			}
			tmp := string(val)
			row.PString = &tmp
		}
		i++
	}

	if all || cols.SelectPBytes {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PBytes", i, vals[i], vals[i], "*[]byte")
			}
			tmp := []byte(val)
			row.PBytes = &tmp
		}
		i++
	}

	if all || cols.SelectPBool {
		if vals[i] != nil {
			val, ok := vals[i].(bool)
			if !ok {
				return nil, fmt.Errorf(errMsg, "PBool", i, vals[i], vals[i], "*bool")
			}
			tmp := bool(val)
			row.PBool = &tmp
		}
		i++
	}

	if all || cols.SelectSelect {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf(errMsg, "Select", i, vals[i], vals[i], "int")
			}
			tmp := int(val)
			row.Select = tmp
		}
		i++
	}

	if cols.count {
		switch val := vals[i].(type) {
		case int64:
			row.Count = val
		case []byte:
			row.Count = parseInt(val)
		default:
			return nil, fmt.Errorf(errMsg, "COUNT(*)", i, vals[i], vals[i], "int64, []byte")
		}
	}

	return &row, nil
}

// Values is a hack to the sql.Rows struct
// since the rows struct does not expose it's lastcols values, or a way to give
// a custom scanner to the Scan method.
// See issue https://github.com/golang/go/issues/22544
func values(r sql.Rows) []driver.Value {
	// some ugly hack to access lastcols field
	rs := reflect.ValueOf(&r).Elem()
	rf := rs.FieldByName("lastcols")

	// overcome panic reflect.Value.Interface: cannot return value obtained from unexported field or method
	rf = reflect.NewAt(rf.Type(), unsafe.Pointer(rf.UnsafeAddr())).Elem()
	return rf.Interface().([]driver.Value)
}
