// Autogenerated by github.com/posener/orm
package allorm

import (
	"strings"

	"github.com/posener/orm/example"
)

const colCount = "COUNT(*)"

type AllCount struct {
	example.All
	Count int64
}

// String returns the SQL query string
func (s *TSelect) String() string {
	return strings.Join([]string{
		"SELECT", s.columns.String(), "FROM all",
		s.where.String(),
		s.groupBy.String(),
		s.orderBy.String(),
		s.page.String(),
	}, " ")

}

// Query the database
func (s *TSelect) Query() ([]example.All, error) {
	// create select statement
	stmt := s.String()
	args := s.where.Args()
	s.orm.log("Query: '%v' %v", stmt, args)
	rows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// extract rows to structures
	var all []example.All
	for rows.Next() {
		var item AllCount
		if err := rows.Scan(s.scanArgs(&item)...); err != nil {
			return nil, err
		}
		all = append(all, item.All)
	}
	return all, rows.Err()
}

// Count add a count column to the query
func (s *TSelect) Count() ([]AllCount, error) {
	s.columns.add(colCount)
	// create select statement
	stmt := s.String()
	args := s.where.Args()
	s.orm.log("Count: '%v' %v", stmt, args)
	rows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// extract rows to structures
	var all []AllCount
	for rows.Next() {
		var item AllCount
		if err := rows.Scan(s.scanArgs(&item)...); err != nil {
			return nil, err
		}
		all = append(all, item)
	}
	return all, rows.Err()
}

// SelectInt Add Int to the selected column of a query
func (s *TSelect) SelectInt() *TSelect {
	s.columns.add("int")
	return s
}

// OrderByInt set order to the query results according to column int
func (s *TSelect) OrderByInt(dir OrderDir) *TSelect {
	s.orderBy.add("int", dir)
	return s
}

// GroupByInt make the query group by column int
func (s *TSelect) GroupByInt() *TSelect {
	s.groupBy.add("int")
	return s
}

// SelectString Add String to the selected column of a query
func (s *TSelect) SelectString() *TSelect {
	s.columns.add("string")
	return s
}

// OrderByString set order to the query results according to column string
func (s *TSelect) OrderByString(dir OrderDir) *TSelect {
	s.orderBy.add("string", dir)
	return s
}

// GroupByString make the query group by column string
func (s *TSelect) GroupByString() *TSelect {
	s.groupBy.add("string")
	return s
}

// SelectBool Add Bool to the selected column of a query
func (s *TSelect) SelectBool() *TSelect {
	s.columns.add("bool")
	return s
}

// OrderByBool set order to the query results according to column bool
func (s *TSelect) OrderByBool(dir OrderDir) *TSelect {
	s.orderBy.add("bool", dir)
	return s
}

// GroupByBool make the query group by column bool
func (s *TSelect) GroupByBool() *TSelect {
	s.groupBy.add("bool")
	return s
}

// SelectTime Add Time to the selected column of a query
func (s *TSelect) SelectTime() *TSelect {
	s.columns.add("time")
	return s
}

// OrderByTime set order to the query results according to column time
func (s *TSelect) OrderByTime(dir OrderDir) *TSelect {
	s.orderBy.add("time", dir)
	return s
}

// GroupByTime make the query group by column time
func (s *TSelect) GroupByTime() *TSelect {
	s.groupBy.add("time")
	return s
}

// scanArgs are list of fields to be given to the sql Scan command
func (s *TSelect) scanArgs(p *AllCount) []interface{} {
	if len(s.columns) == 0 {
		// add to args all the fields of p
		return []interface{}{
			&p.Int,
			&p.String,
			&p.Bool,
			&p.Time,
		}
	}
	m := s.columns.indexMap()
	args := make([]interface{}, len(s.columns))
	if i := m["int"]; i != 0 {
		args[i-1] = &p.Int
	}
	if i := m["string"]; i != 0 {
		args[i-1] = &p.String
	}
	if i := m["bool"]; i != 0 {
		args[i-1] = &p.Bool
	}
	if i := m["time"]; i != 0 {
		args[i-1] = &p.Time
	}
	if i := m[colCount]; i != 0 {
		args[i-1] = &p.Count
	}
	return args
}
