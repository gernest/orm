// Autogenerated by github.com/posener/orm
package allorm

import (
	"database/sql/driver"
	"fmt"
	"strings"
	"time"

	"github.com/posener/orm/example"
)

const colCount = "COUNT(*)"

// TSelect is the struct that holds the SELECT data
type TSelect struct {
	Querier
	Argser
	orm     *ORM
	columns columns
	where   *Where
	groupBy
	orderBy
	page Page
}

func (s *TSelect) Args() []interface{} {
	return s.where.Args()
}

// Where applies where conditions on the query
func (s *TSelect) Where(where *Where) *TSelect {
	s.where = where
	return s
}

// Limit applies rows limit on the query response
func (s *TSelect) Limit(limit int64) *TSelect {
	s.page.limit = limit
	return s
}

// Page applies rows offset and limit on the query response
func (s *TSelect) Page(offset, limit int64) *TSelect {
	s.page.offset = offset
	s.page.limit = limit
	return s
}

type AllCount struct {
	example.All
	Count int64
}

// String returns the SQL query string
func (s *TSelect) String() string {
	return strings.Join([]string{
		"SELECT", s.columns.String(), "FROM 'all'",
		s.where.String(),
		s.groupBy.String(),
		s.orderBy.String(),
		s.page.String(),
	}, " ")

}

// Query the database
func (s *TSelect) Query() ([]example.All, error) {
	// create select statement
	stmt := s.String()
	args := s.Args()
	s.orm.log("Query: '%v' %v", stmt, args)
	rows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// extract rows to structures
	var all []example.All
	for rows.Next() {
		item, err := s.scan(rowValues(*rows))
		if err != nil {
			return nil, err
		}
		all = append(all, item.All)
	}
	return all, rows.Err()
}

// Count add a count column to the query
func (s *TSelect) Count() ([]AllCount, error) {
	s.columns.count = true
	// create select statement
	stmt := s.String()
	args := s.where.Args()
	s.orm.log("Count: '%v' %v", stmt, args)
	rows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	// extract rows to structures
	var all []AllCount
	for rows.Next() {
		item, err := s.scan(rowValues(*rows))
		if err != nil {
			return nil, err
		}
		all = append(all, *item)
	}
	return all, rows.Err()
}

// SelectInt Add Int to the selected column of a query
func (s *TSelect) SelectInt() *TSelect {
	s.columns.SelectInt = true
	return s
}

// OrderByInt set order to the query results according to column int
func (s *TSelect) OrderByInt(dir OrderDir) *TSelect {
	s.orderBy.add("`int`", dir)
	return s
}

// GroupByInt make the query group by column int
func (s *TSelect) GroupByInt() *TSelect {
	s.groupBy.add("`int`")
	return s
}

// SelectString Add String to the selected column of a query
func (s *TSelect) SelectString() *TSelect {
	s.columns.SelectString = true
	return s
}

// OrderByString set order to the query results according to column string
func (s *TSelect) OrderByString(dir OrderDir) *TSelect {
	s.orderBy.add("`string`", dir)
	return s
}

// GroupByString make the query group by column string
func (s *TSelect) GroupByString() *TSelect {
	s.groupBy.add("`string`")
	return s
}

// SelectBool Add Bool to the selected column of a query
func (s *TSelect) SelectBool() *TSelect {
	s.columns.SelectBool = true
	return s
}

// OrderByBool set order to the query results according to column bool
func (s *TSelect) OrderByBool(dir OrderDir) *TSelect {
	s.orderBy.add("`bool`", dir)
	return s
}

// GroupByBool make the query group by column bool
func (s *TSelect) GroupByBool() *TSelect {
	s.groupBy.add("`bool`")
	return s
}

// SelectAuto Add Auto to the selected column of a query
func (s *TSelect) SelectAuto() *TSelect {
	s.columns.SelectAuto = true
	return s
}

// OrderByAuto set order to the query results according to column auto
func (s *TSelect) OrderByAuto(dir OrderDir) *TSelect {
	s.orderBy.add("`auto`", dir)
	return s
}

// GroupByAuto make the query group by column auto
func (s *TSelect) GroupByAuto() *TSelect {
	s.groupBy.add("`auto`")
	return s
}

// SelectTime Add Time to the selected column of a query
func (s *TSelect) SelectTime() *TSelect {
	s.columns.SelectTime = true
	return s
}

// OrderByTime set order to the query results according to column time
func (s *TSelect) OrderByTime(dir OrderDir) *TSelect {
	s.orderBy.add("`time`", dir)
	return s
}

// GroupByTime make the query group by column time
func (s *TSelect) GroupByTime() *TSelect {
	s.groupBy.add("`time`")
	return s
}

// SelectSelect Add Select to the selected column of a query
func (s *TSelect) SelectSelect() *TSelect {
	s.columns.SelectSelect = true
	return s
}

// OrderBySelect set order to the query results according to column select
func (s *TSelect) OrderBySelect(dir OrderDir) *TSelect {
	s.orderBy.add("`select`", dir)
	return s
}

// GroupBySelect make the query group by column select
func (s *TSelect) GroupBySelect() *TSelect {
	s.groupBy.add("`select`")
	return s
}

// scanArgs are list of fields to be given to the sql Scan command
func (s *TSelect) scan(vals []driver.Value) (*AllCount, error) {
	var (
		row AllCount
		all = s.columns.selectAll()
		i   = 0
	)
	if all || s.columns.SelectInt {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf("converting Int: column %d with value %v to int", i, vals[i])
			}
			row.Int = int(val)
		}
		i++
	}
	if all || s.columns.SelectString {
		if vals[i] != nil {
			val, ok := vals[i].([]byte)
			if !ok {
				return nil, fmt.Errorf("converting String: column %d with value %v to string", i, vals[i])
			}
			row.String = string(val)
		}
		i++
	}
	if all || s.columns.SelectBool {
		if vals[i] != nil {
			val, ok := vals[i].(bool)
			if !ok {
				return nil, fmt.Errorf("converting Bool: column %d with value %v to bool", i, vals[i])
			}
			row.Bool = bool(val)
		}
		i++
	}
	if all || s.columns.SelectAuto {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf("converting Auto: column %d with value %v to int", i, vals[i])
			}
			row.Auto = int(val)
		}
		i++
	}
	if all || s.columns.SelectTime {
		if vals[i] != nil {
			val, ok := vals[i].(time.Time)
			if !ok {
				return nil, fmt.Errorf("converting Time: column %d with value %v to time.Time", i, vals[i])
			}
			row.Time = time.Time(val)
		}
		i++
	}
	if all || s.columns.SelectSelect {
		if vals[i] != nil {
			val, ok := vals[i].(int64)
			if !ok {
				return nil, fmt.Errorf("converting Select: column %d with value %v to int", i, vals[i])
			}
			row.Select = int(val)
		}
		i++
	}
	if s.columns.count {
		var ok bool
		row.Count, ok = vals[i].(int64)
		if !ok {
			return nil, fmt.Errorf("converting COUNT(*): column %d with value %v to int64", i, vals[i])
		}
	}
	return &row, nil
}
