// Autogenerated by github.com/posener/orm
package personorm

import (
	"database/sql/driver"
	"fmt"
	"strings"

	"github.com/posener/orm/example"
)

const colCount = "COUNT(*)"

type PersonCount struct {
	example.Person
	Count int64
}

// String returns the SQL query string
func (s *TSelect) String() string {
	return strings.Join([]string{
		"SELECT", s.columns.String(), "FROM 'person'",
		s.where.String(),
		s.groupBy.String(),
		s.orderBy.String(),
		s.page.String(),
	}, " ")

}

// Query the database
func (s *TSelect) Query() ([]example.Person, error) {
	// create select statement
	stmt := s.String()
	args := s.Args()
	s.orm.log("Query: '%v' %v", stmt, args)
	dbRows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer dbRows.Close()

	rows := Rows{Rows: dbRows} // this is a hack to access lastcols field

	// extract rows to structures
	var all []example.Person
	for rows.Next() {
		item, err := s.scan(rows.Values())
		if err != nil {
			return nil, err
		}
		all = append(all, item.Person)
	}
	return all, rows.Err()
}

// Count add a count column to the query
func (s *TSelect) Count() ([]PersonCount, error) {
	s.columns.add(colCount)
	// create select statement
	stmt := s.String()
	args := s.where.Args()
	s.orm.log("Count: '%v' %v", stmt, args)
	dbRows, err := s.orm.db.Query(stmt, args...)
	if err != nil {
		return nil, err
	}
	defer dbRows.Close()

	rows := Rows{Rows: dbRows} // this is a hack to access lastcols field

	// extract rows to structures
	var all []PersonCount
	for rows.Next() {
		item, err := s.scan(rows.Values())
		if err != nil {
			return nil, err
		}
		all = append(all, *item)
	}
	return all, rows.Err()
}

// SelectName Add Name to the selected column of a query
func (s *TSelect) SelectName() *TSelect {
	s.columns.add("`name`")
	return s
}

// OrderByName set order to the query results according to column name
func (s *TSelect) OrderByName(dir OrderDir) *TSelect {
	s.orderBy.add("`name`", dir)
	return s
}

// GroupByName make the query group by column name
func (s *TSelect) GroupByName() *TSelect {
	s.groupBy.add("`name`")
	return s
}

// SelectAge Add Age to the selected column of a query
func (s *TSelect) SelectAge() *TSelect {
	s.columns.add("`age`")
	return s
}

// OrderByAge set order to the query results according to column age
func (s *TSelect) OrderByAge(dir OrderDir) *TSelect {
	s.orderBy.add("`age`", dir)
	return s
}

// GroupByAge make the query group by column age
func (s *TSelect) GroupByAge() *TSelect {
	s.groupBy.add("`age`")
	return s
}

// scanArgs are list of fields to be given to the sql Scan command
func (s *TSelect) scan(vals []driver.Value) (*PersonCount, error) {
	var row PersonCount
	if len(s.columns) == 0 {
		// add to args all the fields of row
		if vals[0] != nil {
			val, ok := vals[0].([]byte)
			if !ok {
				return nil, fmt.Errorf("converting Name column 0 with value %v to string", vals[0])
			}
			row.Name = string(val)
		}
		if vals[1] != nil {
			val, ok := vals[1].(int64)
			if !ok {
				return nil, fmt.Errorf("converting Age column 1 with value %v to int", vals[1])
			}
			row.Age = int(val)
		}

	}
	m := s.columns.indexMap()
	if i := m["`name`"] - 1; i != -1 {
		val, ok := vals[i].([]byte)
		if !ok {
			return nil, fmt.Errorf("converting Name: column %d with value %v to string", i, vals[i])
		}
		row.Name = string(val)
	}
	if i := m["`age`"] - 1; i != -1 {
		val, ok := vals[i].(int64)
		if !ok {
			return nil, fmt.Errorf("converting Age: column %d with value %v to int", i, vals[i])
		}
		row.Age = int(val)
	}
	if i := m[colCount] - 1; i != -1 {
		var ok bool
		row.Count, ok = vals[i].(int64)
		if !ok {
			return nil, fmt.Errorf("converting COUNT(*): column %d with value %v to int64", i, vals[i])
		}
	}
	return &row, nil
}
